//! <!-- markdown-link-check-disable -->
//! # Couple
//!
//! Run `cargo doc --package xpmrl-couple --open` to view this pallet's documentation.
//!
//! A module dedicated to processing two option proposals
//!
//! - [`xpmrl_couple::Config`](./pallet/trait.Config.html)
//! - [`Call`](./pallet/enum.Call.html)
//! - [`Pallet`](./pallet/struct.Pallet.html)
//!
//! ## Overview
//!
//! This module allows users to participate in the sale and liquidity of proposals, and users
//! can earn the corresponding settlement currency through this module
//!
//! The transaction fees generated by buying and selling will be given to the liquidity provider,
//! who can provide liquidity and participate in the total market pool
//!
//! 10% of the transaction fee is proposed by the provider, and 90% is given to the liquidity
//! provider, and the final transaction fee is allocated according to the proportion of liquidity.
//!
//! For the specific rules of buying and selling, please refer to our white paper
//!

#![cfg_attr(not(feature = "std"), no_std)]

pub use pallet::*;

#[cfg(test)]
mod mock;

#[cfg(test)]
mod tests;

/// Import macros about storage-related operations
pub(crate) mod macros;

use frame_support::{
    dispatch::{DispatchResultWithPostInfo, Weight},
    ensure,
    traits::Time,
};
use frame_system::{pallet_prelude::OriginFor, RawOrigin};
use num_traits::pow::pow;
use sp_runtime::{
    traits::{CheckedAdd, CheckedDiv, CheckedMul, CheckedSub, IntegerSquareRoot, One, Zero},
    DispatchError,
};
use sp_std::vec::Vec;
use xpmrl_traits::{
    couple::LiquidityCouple,
    pool::{LiquidityPool, LiquiditySubPool},
    tokens::Tokens,
    ProposalStatus,
};
use xpmrl_utils::{runtime_format, storage_try_mutate};

#[frame_support::pallet]
pub mod pallet {
    use super::{
        proposal_total_market_fee_try_mutate, proposal_total_market_liquid_try_mutate,
        proposal_total_market_try_mutate, proposal_total_optional_market_try_mutate, value_changed,
    };
    use frame_support::{dispatch::DispatchResultWithPostInfo, pallet_prelude::*, traits::Time};
    use frame_system::pallet_prelude::*;
    use sp_runtime::traits::{CheckedAdd, CheckedDiv, CheckedMul, CheckedSub, Zero};
    use sp_std::{cmp, vec::Vec};
    use xpmrl_traits::{
        pool::LiquidityPool, system::ProposalSystem, tokens::Tokens, ProposalStatus,
    };
    use xpmrl_utils::{storage_try_mutate, sub_abs, with_transaction_result};

    pub(crate) type TokensOf<T> =
        <T as ProposalSystem<<T as frame_system::Config>::AccountId>>::Tokens;
    pub(crate) type CurrencyIdOf<T> =
        <TokensOf<T> as Tokens<<T as frame_system::Config>::AccountId>>::CurrencyId;
    pub(crate) type BalanceOf<T> =
        <TokensOf<T> as Tokens<<T as frame_system::Config>::AccountId>>::Balance;
    pub(crate) type CategoryIdOf<T> =
        <T as ProposalSystem<<T as frame_system::Config>::AccountId>>::CategoryId;
    pub(crate) type ProposalIdOf<T> =
        <T as ProposalSystem<<T as frame_system::Config>::AccountId>>::ProposalId;
    type VersionIdOf<T> = <T as ProposalSystem<<T as frame_system::Config>::AccountId>>::VersionId;
    pub(crate) type TimeOf<T> = <T as ProposalSystem<<T as frame_system::Config>::AccountId>>::Time;
    pub(crate) type MomentOf<T> = <TimeOf<T> as Time>::Moment;

    macro_rules! ensure_optional_id_belong_proposal {
        ($id: ident, $proposal_id: ident) => {
            let (asset_id_1, asset_id_2) =
                PoolPairs::<T>::get($proposal_id).ok_or(Error::<T>::ProposalIdNotExist)?;
            ensure!(
                $id == asset_id_1 || $id == asset_id_2,
                Error::<T>::CurrencyIdNotFound
            );
        };
    }

    /// Basic attributes of the proposal
    #[derive(PartialEq, Eq, Clone, RuntimeDebug, Encode, Decode, Default)]
    pub struct Proposal<CategoryId> {
        pub title: Vec<u8>,
        /// The category of the proposal, such as sports, competition
        pub category_id: CategoryId,
        /// The specific description of the proposal
        pub detail: Vec<u8>,
    }

    /// This is the pallet's configuration trait
    ///
    /// Inherited from the proposal pallet, it can use the related functions of the proposal
    /// pallet, which is equivalent to deriving the function of the proposal pallet.
    #[pallet::config]
    pub trait Config:
        frame_system::Config + ProposalSystem<<Self as frame_system::Config>::AccountId>
    {
        type Event: From<Event<Self>> + IsType<<Self as frame_system::Config>::Event>;
        type Pool: LiquidityPool<Self>;

        #[pallet::constant]
        type CurrentLiquidateVersionId: Get<VersionIdOf<Self>>;
    }

    #[pallet::pallet]
    #[pallet::generate_store(pub(super) trait Store)]
    pub struct Pallet<T>(_);

    /// store the basic attributes of all proposals.
    #[pallet::storage]
    #[pallet::getter(fn proposals)]
    pub type Proposals<T: Config> =
        StorageMap<_, Blake2_128Concat, ProposalIdOf<T>, Proposal<T::CategoryId>, OptionQuery>;

    /// storage proposal closed time, It's also the end time. After the end, you can upload the
    /// results
    #[pallet::storage]
    #[pallet::getter(fn proposal_close_time)]
    pub type ProposalCloseTime<T: Config> =
        StorageMap<_, Blake2_128Concat, ProposalIdOf<T>, MomentOf<T>, OptionQuery>;

    /// It stores the creation time of the proposal, which is mainly used to determine whether the
    /// proposal has expired and needs to be closed. If there is no heat after the proposal is put
    /// forward, it will be closed after a period of time.
    #[pallet::storage]
    #[pallet::getter(fn proposal_create_time)]
    pub type ProposalCreateTime<T: Config> =
        StorageMap<_, Blake2_128Concat, ProposalIdOf<T>, MomentOf<T>, OptionQuery>;

    /// Time when the proposal enters the announcement
    #[pallet::storage]
    #[pallet::getter(fn proposal_announcement_time)]
    pub type ProposalAnnouncementTime<T: Config> =
        StorageMap<_, Blake2_128Concat, ProposalIdOf<T>, MomentOf<T>>;

    /// It stores the option tokens of the proposal
    #[pallet::storage]
    #[pallet::getter(fn pool_pairs)]
    pub type PoolPairs<T: Config> = StorageMap<
        _,
        Blake2_128Concat,
        ProposalIdOf<T>,
        (CurrencyIdOf<T>, CurrencyIdOf<T>),
        OptionQuery,
    >;

    /// It stores the settlement token of the proposal
    #[pallet::storage]
    #[pallet::getter(fn proposal_currency_id)]
    pub type ProposalCurrencyId<T: Config> =
        StorageMap<_, Blake2_128Concat, ProposalIdOf<T>, CurrencyIdOf<T>, OptionQuery>;

    #[pallet::storage]
    #[pallet::getter(fn proposal_total_volume)]
    pub type ProposalTotalVolume<T: Config> =
        StorageMap<_, Blake2_128Concat, ProposalIdOf<T>, BalanceOf<T>, OptionQuery>;

    /// It stores the liquidity token of the proposal
    #[pallet::storage]
    #[pallet::getter(fn proposal_liquidate_currency_id)]
    pub type ProposalLiquidateCurrencyId<T: Config> =
        StorageMap<_, Blake2_128Concat, ProposalIdOf<T>, CurrencyIdOf<T>, OptionQuery>;

    /// It stores the fee rate of the proposal
    #[pallet::storage]
    #[pallet::getter(fn proposal_total_earn_trading_fee)]
    pub type ProposalTotalEarnTradingFee<T: Config> =
        StorageMap<_, Blake2_128Concat, ProposalIdOf<T>, u32, OptionQuery>;

    /// It stores the results of the proposal
    #[pallet::storage]
    #[pallet::getter(fn proposal_result)]
    pub type ProposalResult<T: Config> =
        StorageMap<_, Blake2_128Concat, ProposalIdOf<T>, CurrencyIdOf<T>, OptionQuery>;

    /// It stores the participating accounts of the proposal and how many settlement tokens it has
    /// deposited into the proposal
    #[pallet::storage]
    #[pallet::getter(fn proposal_account_info)]
    pub type ProposalAccountInfo<T: Config> = StorageDoubleMap<
        _,
        Blake2_128Concat,
        ProposalIdOf<T>,
        Twox64Concat,
        T::AccountId,
        BalanceOf<T>,
        OptionQuery,
    >;

    /// It stores the amount of all settlement currencies deposited in the proposal
    #[pallet::storage]
    #[pallet::getter(fn proposal_total_market)]
    pub type ProposalTotalMarket<T: Config> =
        StorageMap<_, Blake2_128Concat, ProposalIdOf<T>, BalanceOf<T>, OptionQuery>;

    /// It stores the number of option currencies for the proposal
    #[pallet::storage]
    #[pallet::getter(fn proposal_total_optional_market)]
    pub type ProposalTotalOptionalMarket<T: Config> =
        StorageMap<_, Blake2_128Concat, ProposalIdOf<T>, (BalanceOf<T>, BalanceOf<T>), OptionQuery>;

    /// It stores the final option currency information of the proposal, because after the proposal
    /// is over, as the user clears and liquidity is withdrawn, the total pool number will also
    /// change, which will affect the userâ€™s revenue ratio, so it needs to be fixed after the
    /// proposal ends. Number of assets.
    #[pallet::storage]
    #[pallet::getter(fn proposal_finally_optional_market)]
    pub type ProposalFinallyTotalOptionalMarket<T: Config> =
        StorageMap<_, Blake2_128Concat, ProposalIdOf<T>, (BalanceOf<T>, BalanceOf<T>), OptionQuery>;

    /// It stores the total fee of the proposal
    #[pallet::storage]
    #[pallet::getter(fn proposal_total_market_fee)]
    pub type ProposalTotalMarketFee<T: Config> =
        StorageMap<_, Blake2_128Concat, ProposalIdOf<T>, BalanceOf<T>, OptionQuery>;

    /// It stores all the final fees of the proposal
    ///
    /// Same as `ProposalFinallyTotalOptionalMarket`
    #[pallet::storage]
    #[pallet::getter(fn proposal_finally_market_fee)]
    pub type ProposalFinallyMarketFee<T: Config> =
        StorageMap<_, Blake2_128Concat, ProposalIdOf<T>, BalanceOf<T>, OptionQuery>;

    /// It stores all the liquidity of the proposal
    #[pallet::storage]
    #[pallet::getter(fn proposal_total_market_liquid)]
    pub type ProposalTotalMarketLiquid<T: Config> =
        StorageMap<_, Blake2_128Concat, ProposalIdOf<T>, BalanceOf<T>, OptionQuery>;

    /// It stores all the final liquidity of the proposal
    ///
    /// Same as `ProposalFinallyTotalOptionalMarket`
    #[pallet::storage]
    #[pallet::getter(fn proposal_finally_market_liquid)]
    pub type ProposalFinallyMarketLiquid<T: Config> =
        StorageMap<_, Blake2_128Concat, ProposalIdOf<T>, BalanceOf<T>, OptionQuery>;

    /// It stores how much commission the provider of the proposal has withdrawn
    #[pallet::storage]
    #[pallet::getter(fn proposal_owner_already_withdrawn_fee)]
    pub type ProposalOwnerAlreadyWithdrawnFee<T: Config> = StorageDoubleMap<
        _,
        Blake2_128Concat,
        ProposalIdOf<T>,
        Twox64Concat,
        T::AccountId,
        BalanceOf<T>,
        OptionQuery,
    >;

    #[pallet::event]
    #[pallet::metadata(T::AccountId = "AccountId")]
    #[pallet::generate_deposit(pub(super) fn deposit_event)]
    pub enum Event<T: Config> {
        AddLiquidity(T::AccountId, ProposalIdOf<T>, CurrencyIdOf<T>, BalanceOf<T>),
        RemoveLiquidity(T::AccountId, ProposalIdOf<T>, CurrencyIdOf<T>, BalanceOf<T>),
        Buy(T::AccountId, ProposalIdOf<T>, CurrencyIdOf<T>, BalanceOf<T>),
        Sell(T::AccountId, ProposalIdOf<T>, CurrencyIdOf<T>, BalanceOf<T>),
        /// A liquidation event occurs after the liquidation, and the amount of liquidation will be
        /// included in the event
        Retrieval(T::AccountId, ProposalIdOf<T>, CurrencyIdOf<T>, BalanceOf<T>),
        SetResult(ProposalIdOf<T>, CurrencyIdOf<T>),
        NewProposal(T::AccountId, ProposalIdOf<T>, CurrencyIdOf<T>),
    }

    #[pallet::error]
    pub enum Error<T> {
        /// When buying, selling or clearing, if the currency id you enter is not the id of the
        /// option currency, this error will be thrown
        CurrencyIdNotFound,
        /// The status of the current proposal is incorrect, and the current operation is not
        /// supported.
        ProposalAbnormalState,
        /// A non-existent proposal was executed
        ProposalIdNotExist,
        /// During liquidation, this error will be thrown if the proposal does not have a result
        /// set
        ProposalNotResult,
        /// The quantity overflowed during calculation
        BalanceOverflow,
        /// The equation has no real solution
        NoRealNumber,
        InsufficientBalance,
        CategoryIdNotZero,
        TokenIdNotZero,
        NumberMustMoreThanZero,
        CloseTimeMustLargeThanNow,
        CurrencyIdNotAllowed,
        /// The proposal id has reached the upper limit
        ProposalIdOverflow,
    }

    #[pallet::hooks]
    impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {
        /// When the block is encapsulated, execute the following hook function
        ///
        /// At this time, it is used to automatically expire the proposal
        fn on_initialize(n: T::BlockNumber) -> Weight {
            Self::begin_block(n).unwrap_or_else(|e| {
                sp_runtime::print(e);
                0
            })
        }
    }

    #[pallet::call]
    impl<T: Config> Pallet<T> {
        /// Create a new proposal
        ///
        /// The dispatch origin for this call must be `Signed` by the transactor.
        #[pallet::weight(1_000 + T::DbWeight::get().reads_writes(1, 1))]
        pub fn new_proposal(
            origin: OriginFor<T>,
            title: Vec<u8>,
            optional: [Vec<u8>; 2],
            close_time: MomentOf<T>,
            category_id: CategoryIdOf<T>,
            currency_id: CurrencyIdOf<T>,
            number: BalanceOf<T>,
            earn_fee: u32,
            detail: Vec<u8>,
        ) -> DispatchResultWithPostInfo {
            let who = ensure_signed(origin)?;
            ensure!(category_id > Zero::zero(), Error::<T>::CategoryIdNotZero);
            ensure!(currency_id > Zero::zero(), Error::<T>::TokenIdNotZero);
            ensure!(number > Zero::zero(), Error::<T>::NumberMustMoreThanZero);
            let now = <TimeOf<T> as Time>::now();
            let minimum_interval_time = T::Pool::get_proposa_minimum_interval_time();
            ensure!(
                close_time - now > minimum_interval_time,
                Error::<T>::CloseTimeMustLargeThanNow
            );
            ensure!(
                !T::Pool::is_currency_id_used(currency_id),
                Error::<T>::CurrencyIdNotAllowed
            );
            let proposal_id = with_transaction_result(|| {
                let version: VersionIdOf<T> = T::CurrentLiquidateVersionId::get();
                let proposal_id = T::Pool::get_next_proposal_id()?;
                let (yes_id, no_id, lp_id) = Self::init_pool(
                    &who,
                    proposal_id,
                    title,
                    close_time,
                    category_id,
                    currency_id,
                    optional,
                    number,
                    earn_fee,
                    detail,
                )?;
                T::Pool::init_proposal(
                    proposal_id,
                    &who,
                    ProposalStatus::OriginalPrediction,
                    version,
                );
                T::Pool::append_used_currency(yes_id);
                T::Pool::append_used_currency(no_id);
                T::Pool::append_used_currency(lp_id);
                Ok(proposal_id)
            })?;
            Self::deposit_event(Event::NewProposal(who, proposal_id, currency_id));
            Ok(().into())
        }

        /// Provide liquidity to proposals
        ///
        /// The dispatch origin for this call must be `Signed` by the transactor.
        #[pallet::weight(10_000 + T::DbWeight::get().writes(1))]
        pub fn add_liquidity(
            origin: OriginFor<T>,
            proposal_id: ProposalIdOf<T>,
            number: BalanceOf<T>,
        ) -> DispatchResultWithPostInfo {
            let who = ensure_signed(origin)?;
            let status = T::Pool::get_proposal_state(proposal_id)?;
            ensure!(
                status == ProposalStatus::FormalPrediction,
                Error::<T>::ProposalAbnormalState
            );
            let currency_id =
                ProposalCurrencyId::<T>::get(proposal_id).ok_or(Error::<T>::ProposalIdNotExist)?;
            let (asset_id_1, asset_id_2) =
                PoolPairs::<T>::get(proposal_id).ok_or(Error::<T>::ProposalIdNotExist)?;
            let liquidate_currency_id = ProposalLiquidateCurrencyId::<T>::get(proposal_id)
                .ok_or(Error::<T>::ProposalIdNotExist)?;
            with_transaction_result(|| {
                <TokensOf<T> as Tokens<T::AccountId>>::donate(currency_id, &who, number)?;
                <TokensOf<T> as Tokens<T::AccountId>>::mint_donate(asset_id_1, number)?;
                <TokensOf<T> as Tokens<T::AccountId>>::mint_donate(asset_id_2, number)?;
                <TokensOf<T> as Tokens<T::AccountId>>::mint(liquidate_currency_id, &who, number)?;
                proposal_total_optional_market_try_mutate!(proposal_id, o1, o2, {
                    let new_o1 = o1.checked_add(&number).ok_or(Error::<T>::BalanceOverflow)?;
                    let new_o2 = o2.checked_add(&number).ok_or(Error::<T>::BalanceOverflow)?;
                    (new_o1, new_o2)
                })?;
                proposal_total_market_liquid_try_mutate!(
                    proposal_id,
                    old_value,
                    old_value
                        .checked_add(&number)
                        .ok_or(Error::<T>::BalanceOverflow)?
                )?;
                Self::total_and_account_add(proposal_id, &who, number)?;
                Ok(())
            })?;
            Self::deposit_event(Event::AddLiquidity(who, proposal_id, currency_id, number));
            Ok(().into())
        }

        /// Get back your own assets through liquidity
        ///
        /// The dispatch origin for this call must be `Signed` by the transactor.
        #[pallet::weight(10_000 + T::DbWeight::get().writes(1))]
        pub fn remove_liquidity(
            origin: OriginFor<T>,
            proposal_id: ProposalIdOf<T>,
            number: BalanceOf<T>,
        ) -> DispatchResultWithPostInfo {
            let who = ensure_signed(origin)?;
            let status = T::Pool::get_proposal_state(proposal_id)?;
            ensure!(
                status == ProposalStatus::End,
                Error::<T>::ProposalAbnormalState
            );
            let currency_id =
                ProposalCurrencyId::<T>::get(proposal_id).ok_or(Error::<T>::ProposalIdNotExist)?;
            let liquidate_currency_id = ProposalLiquidateCurrencyId::<T>::get(proposal_id)
                .ok_or(Error::<T>::ProposalIdNotExist)?;
            let (asset_id_1, asset_id_2) =
                PoolPairs::<T>::get(proposal_id).ok_or(Error::<T>::ProposalIdNotExist)?;
            let (finally_o1, finally_o2) =
                ProposalFinallyTotalOptionalMarket::<T>::get(proposal_id)
                    .ok_or(Error::<T>::ProposalIdNotExist)?;
            with_transaction_result(|| {
                <TokensOf<T> as Tokens<T::AccountId>>::burn(liquidate_currency_id, &who, number)?;
                proposal_total_market_liquid_try_mutate!(
                    proposal_id,
                    old_value,
                    old_value.checked_sub(&number).unwrap_or_else(Zero::zero)
                )?;
                let total_liquid =
                    ProposalFinallyMarketLiquid::<T>::get(proposal_id).unwrap_or_else(Zero::zero);
                let fee = Self::get_fee_of_liquid(proposal_id, number, total_liquid)?;
                let creater_fee = Self::get_fee_of_creator(&who, proposal_id)?;
                let fee = fee
                    .checked_add(&creater_fee)
                    .ok_or(Error::<T>::BalanceOverflow)?;
                proposal_total_market_fee_try_mutate!(
                    proposal_id,
                    old_value,
                    old_value.checked_sub(&fee).unwrap_or_else(Zero::zero)
                )?;
                let (o1, o2) = proposal_total_optional_market_try_mutate!(proposal_id, o1, o2, {
                    let new_o1 = finally_o1
                        .checked_mul(&number)
                        .ok_or(Error::<T>::BalanceOverflow)?;
                    let new_o1 = new_o1
                        .checked_div(&total_liquid)
                        .ok_or(Error::<T>::BalanceOverflow)?;
                    let new_o1 = o1.checked_sub(&new_o1).unwrap_or_else(Zero::zero);

                    let new_o2 = finally_o2
                        .checked_mul(&number)
                        .ok_or(Error::<T>::BalanceOverflow)?;
                    let new_o2 = new_o2
                        .checked_div(&total_liquid)
                        .ok_or(Error::<T>::BalanceOverflow)?;
                    let new_o2 = o2.checked_sub(&new_o2).unwrap_or_else(Zero::zero);
                    (new_o1, new_o2)
                })?;
                let min = cmp::min(o1, o2);
                <TokensOf<T> as Tokens<T::AccountId>>::burn_donate(asset_id_1, min)?;
                <TokensOf<T> as Tokens<T::AccountId>>::burn_donate(asset_id_2, min)?;
                Self::total_and_account_sub(proposal_id, &who, min)?;
                let actual_amount = min.checked_add(&fee).ok_or(Error::<T>::BalanceOverflow)?;
                <TokensOf<T> as Tokens<T::AccountId>>::appropriation(
                    currency_id,
                    &who,
                    actual_amount,
                )?;
                <TokensOf<T> as Tokens<T::AccountId>>::appropriation(
                    asset_id_1,
                    &who,
                    o1.checked_sub(&min).unwrap_or_else(Zero::zero),
                )?;
                <TokensOf<T> as Tokens<T::AccountId>>::appropriation(
                    asset_id_2,
                    &who,
                    o2.checked_sub(&min).unwrap_or_else(Zero::zero),
                )?;
                Ok(())
            })?;
            Self::deposit_event(Event::RemoveLiquidity(
                who,
                proposal_id,
                currency_id,
                number,
            ));
            Ok(().into())
        }

        /// Buy option currency
        ///
        /// The dispatch origin for this call must be `Signed` by the transactor.
        #[pallet::weight(10_000 + T::DbWeight::get().reads_writes(1,1))]
        pub fn buy(
            origin: OriginFor<T>,
            proposal_id: ProposalIdOf<T>,
            optional_currency_id: CurrencyIdOf<T>,
            number: BalanceOf<T>,
        ) -> DispatchResultWithPostInfo {
            let who = ensure_signed(origin)?;
            let status = T::Pool::get_proposal_state(proposal_id)?;
            ensure!(
                status == ProposalStatus::FormalPrediction,
                Error::<T>::ProposalAbnormalState
            );
            let currency_id =
                ProposalCurrencyId::<T>::get(proposal_id).ok_or(Error::<T>::ProposalIdNotExist)?;
            ensure_optional_id_belong_proposal!(optional_currency_id, proposal_id);
            let other_currency = Self::get_other_optional_id(proposal_id, optional_currency_id)?;
            let actual_number = with_transaction_result(|| {
                let (actual_number, fee) = Self::get_fee(proposal_id, number)?;
                <TokensOf<T> as Tokens<T::AccountId>>::donate(currency_id, &who, number)?;
                <TokensOf<T> as Tokens<T::AccountId>>::mint(
                    optional_currency_id,
                    &who,
                    actual_number,
                )?;
                <TokensOf<T> as Tokens<T::AccountId>>::mint_donate(
                    other_currency.1,
                    actual_number,
                )?;
                let (d1, d2) = proposal_total_optional_market_try_mutate!(proposal_id, o1, o2, {
                    let old_pair = [o1, o2];
                    let new_pair =
                        Self::add_and_adjust_pool(other_currency.0, actual_number, &old_pair)?;
                    (new_pair[0], new_pair[1])
                })?;
                let diff = [d1, d2][1 - other_currency.0];
                Self::total_and_account_add(proposal_id, &who, actual_number)?;
                proposal_total_market_fee_try_mutate!(
                    proposal_id,
                    old_value,
                    old_value
                        .checked_add(&fee)
                        .ok_or(Error::<T>::BalanceOverflow)?
                )?;
                <TokensOf<T> as Tokens<T::AccountId>>::appropriation(
                    optional_currency_id,
                    &who,
                    diff,
                )?;
                ProposalTotalVolume::<T>::try_mutate(
                    proposal_id,
                    |optional| -> Result<(), DispatchError> {
                        let old = optional.unwrap_or_else(Zero::zero);
                        let new = old.checked_add(&number).unwrap_or_else(Zero::zero);
                        *optional = Some(new);
                        Ok(())
                    },
                )?;
                Ok(actual_number)
            })?;
            Self::deposit_event(Event::Buy(
                who,
                proposal_id,
                optional_currency_id,
                actual_number,
            ));
            Ok(().into())
        }

        /// Sell option currency
        ///
        /// The dispatch origin for this call must be `Signed` by the transactor.
        #[pallet::weight(10_000 + T::DbWeight::get().reads_writes(1,1))]
        pub fn sell(
            origin: OriginFor<T>,
            proposal_id: ProposalIdOf<T>,
            optional_currency_id: CurrencyIdOf<T>,
            number: BalanceOf<T>,
        ) -> DispatchResultWithPostInfo {
            let who = ensure_signed(origin)?;
            let status = T::Pool::get_proposal_state(proposal_id)?;
            ensure!(
                status == ProposalStatus::FormalPrediction,
                Error::<T>::ProposalAbnormalState
            );
            let currency_id =
                ProposalCurrencyId::<T>::get(proposal_id).ok_or(Error::<T>::ProposalIdNotExist)?;
            ensure_optional_id_belong_proposal!(optional_currency_id, proposal_id);
            let other_currency = Self::get_other_optional_id(proposal_id, optional_currency_id)?;
            let actual_number = with_transaction_result(|| {
                <TokensOf<T> as Tokens<T::AccountId>>::donate(optional_currency_id, &who, number)?;
                let (d1, d2) = proposal_total_optional_market_try_mutate!(proposal_id, o1, o2, {
                    let old_pair = [o1, o2];
                    let actual_number = Self::get_sell_result(
                        proposal_id,
                        &old_pair,
                        number,
                        optional_currency_id,
                    )?;
                    let new_pair =
                        Self::add_and_adjust_pool(1 - other_currency.0, actual_number, &old_pair)?;
                    (new_pair[0], new_pair[1])
                })?;
                let diff = [d1, d2];
                let last_select_currency = number
                    .checked_sub(&diff[1 - other_currency.0])
                    .unwrap_or_else(Zero::zero);
                let acquired_currency = diff[other_currency.0];
                let min = cmp::min(last_select_currency, acquired_currency);
                <TokensOf<T> as Tokens<T::AccountId>>::burn_donate(other_currency.1, min)?;
                ProposalTotalVolume::<T>::try_mutate(
                    proposal_id,
                    |optional| -> Result<(), DispatchError> {
                        let old = optional.unwrap_or_else(Zero::zero);
                        let new = old.checked_add(&min).unwrap_or_else(Zero::zero);
                        *optional = Some(new);
                        Ok(())
                    },
                )?;
                let (actual_number, fee) = Self::get_fee(proposal_id, min)?;
                proposal_total_market_fee_try_mutate!(
                    proposal_id,
                    old_value,
                    old_value
                        .checked_add(&fee)
                        .ok_or(Error::<T>::BalanceOverflow)?
                )?;
                Self::total_and_account_sub(proposal_id, &who, min)?;
                <TokensOf<T> as Tokens<T::AccountId>>::appropriation(
                    currency_id,
                    &who,
                    actual_number,
                )?;
                <TokensOf<T> as Tokens<T::AccountId>>::appropriation(
                    optional_currency_id,
                    &who,
                    last_select_currency
                        .checked_sub(&min)
                        .unwrap_or_else(Zero::zero),
                )?;
                <TokensOf<T> as Tokens<T::AccountId>>::appropriation(
                    other_currency.1,
                    &who,
                    acquired_currency
                        .checked_sub(&min)
                        .unwrap_or_else(Zero::zero),
                )?;
                Ok(actual_number)
            })?;
            Self::deposit_event(Event::Sell(
                who,
                proposal_id,
                optional_currency_id,
                actual_number,
            ));
            Ok(().into())
        }

        /// Settlement option currency, get settlement currency
        ///
        /// The dispatch origin for this call must be `Signed` by the transactor.
        #[pallet::weight(10_000 + T::DbWeight::get().reads_writes(1, 1))]
        pub fn retrieval(
            origin: OriginFor<T>,
            proposal_id: ProposalIdOf<T>,
            optional_currency_id: CurrencyIdOf<T>,
            number: BalanceOf<T>,
        ) -> DispatchResultWithPostInfo {
            let who = ensure_signed(origin)?;
            let status = T::Pool::get_proposal_state(proposal_id)?;
            ensure!(
                status == ProposalStatus::End,
                Error::<T>::ProposalAbnormalState
            );
            ensure_optional_id_belong_proposal!(optional_currency_id, proposal_id);
            let result_id =
                ProposalResult::<T>::get(proposal_id).ok_or(Error::<T>::ProposalNotResult)?;
            let balance =
                <TokensOf<T> as Tokens<T::AccountId>>::balance(optional_currency_id, &who);
            ensure!(balance >= Zero::zero(), Error::<T>::InsufficientBalance);
            let number = if number >= balance { balance } else { number };
            if optional_currency_id == result_id {
                let currency_id = ProposalCurrencyId::<T>::get(proposal_id)
                    .ok_or(Error::<T>::ProposalIdNotExist)?;
                with_transaction_result(|| {
                    proposal_total_market_try_mutate!(
                        proposal_id,
                        old_amount,
                        old_amount.checked_sub(&number).unwrap_or_else(Zero::zero)
                    )?;
                    <TokensOf<T> as Tokens<T::AccountId>>::burn(result_id, &who, number)?;
                    <TokensOf<T> as Tokens<T::AccountId>>::appropriation(
                        currency_id,
                        &who,
                        number,
                    )?;
                    Ok(())
                })?;
            } else {
                <TokensOf<T> as Tokens<T::AccountId>>::burn(optional_currency_id, &who, number)?;
            }
            Self::deposit_event(Event::Retrieval(who, proposal_id, result_id, balance));
            Ok(().into())
        }

        /// Set result for proposal
        ///
        /// The dispatch origin for this call is `root`.
        #[pallet::weight(10_000 + T::DbWeight::get().reads_writes(1,1))]
        pub fn set_result(
            origin: OriginFor<T>,
            proposal_id: ProposalIdOf<T>,
            currency_id: CurrencyIdOf<T>,
        ) -> DispatchResultWithPostInfo {
            let _ = ensure_root(origin)?;
            let status = T::Pool::get_proposal_state(proposal_id)?;
            ensure!(
                status == ProposalStatus::WaitingForResults,
                Error::<T>::ProposalAbnormalState
            );
            ensure_optional_id_belong_proposal!(currency_id, proposal_id);
            with_transaction_result(|| {
                T::Pool::set_proposal_state(proposal_id, ProposalStatus::End)?;
                ProposalResult::<T>::insert(proposal_id, currency_id);
                Self::finally_locked(proposal_id)?;
                Ok(())
            })?;
            Self::deposit_event(Event::SetResult(proposal_id, currency_id));
            Ok(().into())
        }
    }
}

impl<T: Config> Pallet<T> {
    fn begin_block(_: T::BlockNumber) -> Result<Weight, DispatchError> {
        let now = <TimeOf<T> as Time>::now();
        let expiration_time = T::Pool::proposal_automatic_expiration_time();
        let max_id = T::Pool::max_proposal_id();
        let mut index: ProposalIdOf<T> = Zero::zero();
        loop {
            if index >= max_id {
                break;
            }
            let start =
                ProposalCreateTime::<T>::get(index).ok_or(Error::<T>::ProposalIdNotExist)?;
            let end = ProposalCloseTime::<T>::get(index).ok_or(Error::<T>::ProposalIdNotExist)?;
            let diff = now.checked_sub(&start).unwrap_or_else(Zero::zero);
            let state =
                T::Pool::get_proposal_state(index).unwrap_or(ProposalStatus::OriginalPrediction);
            if diff > expiration_time && state == ProposalStatus::OriginalPrediction {
                T::Pool::set_proposal_state(index, ProposalStatus::End)?;
            } else if now > end {
                if state == ProposalStatus::OriginalPrediction {
                    T::Pool::set_proposal_state(index, ProposalStatus::End)?;
                } else if state == ProposalStatus::FormalPrediction {
                    T::Pool::set_proposal_state(index, ProposalStatus::WaitingForResults)?;
                    ProposalAnnouncementTime::<T>::insert(index, now);
                }
            }
            index = index
                .checked_add(&One::one())
                .ok_or(Error::<T>::ProposalIdOverflow)?;
        }
        Ok(0)
    }

    fn get_other_optional_id(
        proposal_id: ProposalIdOf<T>,
        optional_currency_id: CurrencyIdOf<T>,
    ) -> Result<(usize, CurrencyIdOf<T>), DispatchError> {
        let (asset_id_1, asset_id_2) =
            PoolPairs::<T>::get(proposal_id).ok_or(Error::<T>::ProposalIdNotExist)?;
        let other_currency_id = if optional_currency_id == asset_id_1 {
            (1, asset_id_2)
        } else {
            (0, asset_id_1)
        };
        Ok(other_currency_id)
    }

    fn get_fee_of_liquid(
        proposal_id: ProposalIdOf<T>,
        number: BalanceOf<T>,
        total_liquid: BalanceOf<T>,
    ) -> Result<BalanceOf<T>, DispatchError> {
        let market_fee = ProposalFinallyMarketFee::<T>::get(proposal_id).unwrap_or_else(Zero::zero);

        let decimals = T::Pool::get_earn_trading_fee_decimals();
        let one = pow(10u32, decimals.into());
        let liquidity_provider_fee_rate: u32 = T::Pool::proposal_liquidity_provider_fee_rate();

        let mul_market_fee = market_fee
            .checked_mul(&number)
            .ok_or(Error::<T>::BalanceOverflow)?;
        let mul_market_fee = mul_market_fee
            .checked_mul(&liquidity_provider_fee_rate.into())
            .ok_or(Error::<T>::BalanceOverflow)?;
        let fee = mul_market_fee
            .checked_div(&total_liquid)
            .ok_or(Error::<T>::BalanceOverflow)?;
        let fee = fee
            .checked_div(&one.into())
            .ok_or(Error::<T>::BalanceOverflow)?;
        Ok(fee)
    }

    fn get_fee_of_creator(
        who: &T::AccountId,
        proposal_id: ProposalIdOf<T>,
    ) -> Result<BalanceOf<T>, DispatchError> {
        let owner = T::Pool::proposal_owner(proposal_id)?;
        if owner == *who && !ProposalOwnerAlreadyWithdrawnFee::<T>::contains_key(proposal_id, &who)
        {
            let market_fee =
                ProposalFinallyMarketFee::<T>::get(proposal_id).unwrap_or_else(Zero::zero);

            let decimals = T::Pool::get_earn_trading_fee_decimals();
            let one = pow(10u32, decimals.into());
            let liquidity_provider_fee_rate: u32 = T::Pool::proposal_liquidity_provider_fee_rate();

            let mul_market_fee = market_fee
                .checked_mul(&liquidity_provider_fee_rate.into())
                .ok_or(Error::<T>::BalanceOverflow)?;
            let fee = mul_market_fee
                .checked_div(&one.into())
                .ok_or(Error::<T>::BalanceOverflow)?;
            let fee = market_fee.checked_sub(&fee).unwrap_or_else(Zero::zero);
            ProposalOwnerAlreadyWithdrawnFee::<T>::insert(proposal_id, &who, fee);
            Ok(fee)
        } else {
            Ok(Zero::zero())
        }
    }

    fn finally_locked(proposal_id: ProposalIdOf<T>) -> Result<(), DispatchError> {
        let finally_liquid =
            ProposalTotalMarketLiquid::<T>::get(proposal_id).unwrap_or_else(Zero::zero);
        let finally_fee = ProposalTotalMarketFee::<T>::get(proposal_id).unwrap_or_else(Zero::zero);
        let finally_optional = ProposalTotalOptionalMarket::<T>::get(proposal_id)
            .ok_or(Error::<T>::ProposalIdNotExist)?;
        ProposalFinallyMarketFee::<T>::insert(proposal_id, finally_fee);
        ProposalFinallyMarketLiquid::<T>::insert(proposal_id, finally_liquid);
        ProposalFinallyTotalOptionalMarket::<T>::insert(proposal_id, finally_optional);
        Ok(())
    }

    fn init_pool(
        who: &T::AccountId,
        proposal_id: ProposalIdOf<T>,
        title: Vec<u8>,
        close_time: MomentOf<T>,
        category_id: T::CategoryId,
        currency_id: CurrencyIdOf<T>,
        optional: [Vec<u8>; 2],
        number: BalanceOf<T>,
        earn_fee: u32,
        detail: Vec<u8>,
    ) -> Result<(CurrencyIdOf<T>, CurrencyIdOf<T>, CurrencyIdOf<T>), DispatchError> {
        Proposals::<T>::insert(
            proposal_id,
            Proposal {
                title,
                category_id,
                detail,
            },
        );
        ProposalCloseTime::<T>::insert(proposal_id, close_time);
        ProposalCreateTime::<T>::insert(proposal_id, T::Time::now());
        ProposalCurrencyId::<T>::insert(proposal_id, currency_id);
        <TokensOf<T> as Tokens<T::AccountId>>::donate(currency_id, &who, number)?;
        let decimals = <TokensOf<T> as Tokens<T::AccountId>>::decimals(currency_id)?;
        let asset_id_1 = <TokensOf<T> as Tokens<T::AccountId>>::new_asset(
            optional[0].clone(),
            runtime_format!("{:?}-YES", proposal_id),
            decimals,
        )?;
        let asset_id_2 = <TokensOf<T> as Tokens<T::AccountId>>::new_asset(
            optional[1].clone(),
            runtime_format!("{:?}-NO", proposal_id),
            decimals,
        )?;
        let asset_id_lp = <TokensOf<T> as Tokens<T::AccountId>>::new_asset(
            runtime_format!("LP-{:?}", proposal_id),
            runtime_format!("LP-{:?}", proposal_id),
            decimals,
        )?;

        <TokensOf<T> as Tokens<T::AccountId>>::mint_donate(asset_id_1, number)?;
        <TokensOf<T> as Tokens<T::AccountId>>::mint_donate(asset_id_2, number)?;
        ProposalTotalOptionalMarket::<T>::insert(proposal_id, (number, number));

        ProposalLiquidateCurrencyId::<T>::insert(proposal_id, asset_id_lp);
        <TokensOf<T> as Tokens<T::AccountId>>::mint(asset_id_lp, &who, number)?;

        PoolPairs::<T>::insert(proposal_id, (asset_id_1, asset_id_2));
        ProposalTotalEarnTradingFee::<T>::insert(proposal_id, earn_fee);
        ProposalAccountInfo::<T>::insert(proposal_id, who.clone(), number);
        ProposalTotalMarket::<T>::insert(proposal_id, number);
        ProposalTotalMarketLiquid::<T>::insert(proposal_id, number);
        Ok((asset_id_1, asset_id_2, asset_id_lp))
    }

    fn get_fee(
        proposal_id: ProposalIdOf<T>,
        number: BalanceOf<T>,
    ) -> Result<(BalanceOf<T>, BalanceOf<T>), DispatchError> {
        let fee_decimals: u8 = T::Pool::get_earn_trading_fee_decimals();
        let one = pow(10u32, fee_decimals.into());
        let fee_rate = ProposalTotalEarnTradingFee::<T>::get(proposal_id)
            .ok_or(Error::<T>::ProposalIdNotExist)?;
        let mut rate = number
            .checked_mul(&(fee_rate.into()))
            .ok_or(Error::<T>::BalanceOverflow)?;
        rate = rate
            .checked_div(&(one.into()))
            .ok_or(Error::<T>::BalanceOverflow)?;
        let actual_number = number.checked_sub(&rate).unwrap_or_else(Zero::zero);
        Ok((actual_number, rate))
    }

    fn add_and_adjust_pool(
        to_add: usize,
        number: BalanceOf<T>,
        old_pair: &[BalanceOf<T>; 2],
    ) -> Result<[BalanceOf<T>; 2], DispatchError> {
        let base = old_pair[0]
            .checked_mul(&old_pair[1])
            .ok_or(Error::<T>::BalanceOverflow)?;
        let mut new_pair = *old_pair;
        new_pair[to_add] = new_pair[to_add]
            .checked_add(&number)
            .ok_or(Error::<T>::BalanceOverflow)?;
        new_pair[1 - to_add] = base
            .checked_div(&new_pair[to_add])
            .ok_or(Error::<T>::BalanceOverflow)?;
        Ok(new_pair)
    }

    fn get_sell_result(
        proposal_id: ProposalIdOf<T>,
        pair: &[BalanceOf<T>; 2],
        number: BalanceOf<T>,
        current_currency: CurrencyIdOf<T>,
    ) -> Result<BalanceOf<T>, DispatchError> {
        let a: BalanceOf<T> = One::one();
        let b: BalanceOf<T> = pair[0]
            .checked_add(&pair[1])
            .ok_or(Error::<T>::BalanceOverflow)?;
        let b: BalanceOf<T> = b.checked_sub(&number).unwrap_or_else(Zero::zero);
        let other_currency = Self::get_other_optional_id(proposal_id, current_currency)?;
        let c: BalanceOf<T> = number
            .checked_mul(&pair[1 - other_currency.0])
            .ok_or(Error::<T>::BalanceOverflow)?;
        let _4ac = a.checked_mul(&c).ok_or(Error::<T>::BalanceOverflow)?;
        let _4ac = _4ac
            .checked_mul(&4u32.into())
            .ok_or(Error::<T>::BalanceOverflow)?;
        let _2a = a
            .checked_mul(&2u32.into())
            .ok_or(Error::<T>::BalanceOverflow)?;
        let delta = pow(b, 2)
            .checked_add(&_4ac)
            .ok_or(Error::<T>::BalanceOverflow)?;
        let sqrt_delta = delta.integer_sqrt();
        ensure!(sqrt_delta >= b, Error::<T>::NoRealNumber);
        let tmp = sqrt_delta.checked_sub(&b).unwrap_or_else(Zero::zero);
        Ok(tmp
            .checked_div(&2u32.into())
            .ok_or(Error::<T>::BalanceOverflow)?)
    }

    fn total_and_account_add(
        proposal_id: ProposalIdOf<T>,
        who: &T::AccountId,
        diff: BalanceOf<T>,
    ) -> Result<(), DispatchError> {
        proposal_total_market_try_mutate!(
            proposal_id,
            old_amount,
            old_amount
                .checked_add(&diff)
                .ok_or(Error::<T>::BalanceOverflow)?
        )?;
        proposal_account_info_try_mutate!(
            proposal_id,
            who,
            old_amount,
            old_amount
                .checked_add(&diff)
                .ok_or(Error::<T>::BalanceOverflow)?
        )?;
        Ok(())
    }

    fn total_and_account_sub(
        proposal_id: ProposalIdOf<T>,
        who: &T::AccountId,
        diff: BalanceOf<T>,
    ) -> Result<(), DispatchError> {
        proposal_total_market_try_mutate!(
            proposal_id,
            old_amount,
            old_amount.checked_sub(&diff).unwrap_or_else(Zero::zero)
        )?;
        proposal_account_info_try_mutate!(
            proposal_id,
            who,
            old_amount,
            old_amount.checked_sub(&diff).unwrap_or_else(Zero::zero)
        )?;
        Ok(())
    }
}

impl<T: Config> LiquiditySubPool<T> for Pallet<T> {
    fn finally_locked(proposal_id: ProposalIdOf<T>) -> Result<(), DispatchError> {
        Self::finally_locked(proposal_id)
    }
}

impl<T: Config> LiquidityCouple<T> for Pallet<T> {
    fn proposal_announcement_time(
        proposal_id: ProposalIdOf<T>,
    ) -> Result<MomentOf<T>, DispatchError> {
        ProposalAnnouncementTime::<T>::get(proposal_id).ok_or(Err(Error::<T>::ProposalIdNotExist)?)
    }

    fn proposal_pair(
        proposal_id: ProposalIdOf<T>,
    ) -> Result<(CurrencyIdOf<T>, CurrencyIdOf<T>), DispatchError> {
        PoolPairs::<T>::get(proposal_id).ok_or(Err(Error::<T>::ProposalIdNotExist)?)
    }

    fn set_proposal_result(
        proposal_id: ProposalIdOf<T>,
        result: CurrencyIdOf<T>,
    ) -> Result<(), DispatchError> {
        match Self::set_result(RawOrigin::Root.into(), proposal_id, result) {
            Ok(_) => Ok(()),
            Err(e) => Err(e.error)?,
        }
    }

    fn proposal_liquidate_currency_id(
        proposal_id: ProposalIdOf<T>,
    ) -> Result<CurrencyIdOf<T>, DispatchError> {
        ProposalLiquidateCurrencyId::<T>::get(proposal_id)
            .ok_or(Err(Error::<T>::ProposalIdNotExist)?)
    }

    fn new_couple_proposal(
        origin: OriginFor<T>,
        title: Vec<u8>,
        optional: [Vec<u8>; 2],
        close_time: MomentOf<T>,
        category_id: CategoryIdOf<T>,
        currency_id: CurrencyIdOf<T>,
        number: BalanceOf<T>,
        earn_fee: u32,
        detail: Vec<u8>,
    ) -> DispatchResultWithPostInfo {
        Self::new_proposal(
            origin,
            title,
            optional,
            close_time,
            category_id,
            currency_id,
            number,
            earn_fee,
            detail,
        )
    }
}
